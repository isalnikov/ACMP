package ru.isalnikov.acmp.acmp29;

/**
 * Вы можете вспомнить хоть одного своего знакомого до двадцатилетнего возраста,
 * который в детстве не играл в компьютерные игры? Если да, то может быть вы и
 * сами не знакомы с этим развлечением? Впрочем, трудностей при решении этой
 * задачи это создать не должно.
 *
 * Во многих старых играх с двумерной графикой можно столкнуться с подобной
 * ситуацией. Какой-нибудь герой прыгает по платформам (или островкам), которые
 * висят в воздухе. Он должен перебраться от одного края экрана до другого. При
 * этом при прыжке с одной платформы на соседнюю, у героя уходит |y2-y1| единиц
 * энергии, где y1 и y2 – высоты, на которых расположены эти платформы. Кроме
 * того, у героя есть суперприем, который позволяет перескочить через платформу,
 * но на это затрачивается 3*|y3-y1| единиц энергии. Конечно же, энергию следует
 * расходовать максимально экономно.
 *
 * Предположим, что вам известны координаты всех платформ в порядке от левого
 * края до правого. Сможете ли вы найти, какое минимальное количество энергии
 * потребуется герою, чтобы добраться с первой платформы до последней?
 *
 * Входные данные
 *
 * В первой строке входного файла INPUT.TXT записано количество платформ n (1 ≤
 * n ≤ 30000). Вторая строка содержит n натуральных чисел, не превосходящих
 * 30000 – высоты, на которых располагаются платформы.
 */

import java.io.PrintWriter;
import static java.lang.Integer.min;
import static java.lang.Math.abs;
import java.util.Scanner;
import java.util.stream.IntStream;

public class Main {

    public static void main(String[] args) {
        try (Scanner in = new Scanner(System.in);
                PrintWriter out = new PrintWriter(System.out)) {
            solve(in, out);
        }
    }



    
    private static void solve(Scanner in, PrintWriter out) {
        int n = in.nextInt();
        int[] a = IntStream.range(0, n).map(i -> in.nextInt()).toArray();
        int[] b = new int[n];
        b[0] = 0;
        b[1] = abs(a[1] - a[0]);
        for (int i = 2; i < n; ++i) {
            b[i] = min(b[i - 1] + abs(a[i - 1] - a[i]),
                    b[i - 2] + 3 * abs(a[i - 2] - a[i]));
        }
        out.print(b[n - 1]);
        out.flush();
    }
}
