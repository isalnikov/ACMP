http://www.sql.ru/forum/1097862/bezopasnaya-publikaciya-volatile

Понять, как работает JMM с помощью assembly, можно только в том случае, если вы досконально знаете, как генерирует код JIT. Поэтому, если вы не являетесь разработчиком c2-компилятора, ваши шансы понять JMM через чтение ассемблерного кода стремятся к нулю. Если же вы все таки являетесь им, то вы итак знаете JMM 

А если серьезно, то JMM как раз и был создан для того, что бы его понимали рядовые прикладные программисты, далекие от железа, ассемблера, и прочих низкоуровневых вещей. И понять его без ассемблера можно. Как раз на основе абстрактных примеров, которые вы почему-то просите не приводить.

Теперь по поводу вашего комментария. Мы говорим, что у нас есть следующий класс:
class A a {
    pivate int x = 42;
}
И мы в одном потоке создаем инстанс этого класса, и записываем его в переменную "a", расшаренную между потоками. Вот она:
class Holder {
    public static A a;
}
А другой поток делает следующее: 
System.out.println(a.x)
Вопрос: что распечатает второй поток?

Вариант 1: Вылетит NPE. Вот один из сценариев, который может к этому привести:
1) Thread1: ref = malloc(A.class); // JVM аллоцировала объект, и держит его адрес где-то у себя в потрохах;
2) Thread1: STORE ref.x = 42; // Присвоили дефолтное значение переменной x;
3) Thread2: LOAD a; // Разыменовали "a", что бы пробраться к "x";
4) Thread2: LOAD a.x; // Словили NPE, так как "a" все еще null.
5) Thread1: STORE a = ref; // Записали адрес объекта в переменную "a";

Вариант 2: Будет отпечатано 42. Это произойдет в следующем случае (цифра в начале строки - условный "такт процессора"):
1) Thread1: ref = malloc(A.class); // JVM аллоцировала объект, и держит его адрес где-то у себя в потрохах;
2) Thread1: STORE ref.x = 42; // Присвоили дефолтное значение переменной x;
3) Thread1: STORE a = ref; // Записали адрес объекта в переменную "a";
4) Thread2: LOAD a; // Разыменовали "a", что бы пробраться к "x";
5) Thread2: LOAD a.x; // Добрались до x.

Вариант 3: Будет отпечатано 0. Вот один из сценариев, который может к этом привести:
1) Thread1: ref = malloc(A.class); // JVM аллоцировала объект, и держит его адрес где-то у себя в потрохах;
2) Thread1: STORE a = ref; // Записали адрес объекта в переменную "a";
3) Thread2: LOAD a; // Разыменовали "a", что бы пробраться к "x";
4) Thread2: LOAD a.x; // Добрались до x, а он все еще 0!
5) Thread1: STORE ref.x = 42; // Присвоили дефолтное значение переменной x;
То есть у нас запись в ref.x "убежала" за запись в "a". Для потока Thread1 это не страшно, а вот для потока Thread2 это все ломает.

Теперь мы пишем вот это:
class Holder {
    public static volatile A a;
}
Что это меняет? А то, что теперь записи, которые шли до записи в "а", нельзя переставлять за "а". Поэтому такой сценарий у нас допустим:
1) Thread1: ref = malloc(A.class); // JVM аллоцировала объект, и держит его адрес где-то у себя в потрохах;
2) Thread1: STORE ref.x = 42; // Присвоили дефолтное значение переменной x;
3) Thread1: VOLATILE STORE a = ref; // Записали адрес объекта в переменную "a";

А такой нет:
1) Thread1: ref = malloc(A.class); // JVM аллоцировала объект, и держит его адрес где-то у себя в потрохах;
2) Thread1: VOLATILE STORE a = ref; // Записали адрес объекта в переменную "a";
3) Thread1: STORE ref.x = 42; // ЗАПРЕЩЕНО! 

Поэтому, в таком случае третий сценарий с отпечаткой нуля никогда не возникнет.

, так как вы забываете про самое главное - acquire/release семантику. Я не просто так написал "запрещает оптимизации применительно к самой переменной, и "вокруг" нее".
Вы написали про саму переменную - да, с ней нельзя заигрывать в регистрах, если сказано "прочитать", значит надо прочитать и точка. 
А acquire/release - это как раз про то, что происходит "вокруг" volatile переменной. А именно:
1) При записи в volatile переменную срабатывает release-семантика. Это означает следующее: к моменту завершения волатильной записи должны быть завершены все записи, которые по коду шли до нее. Поэтому вот такой сценарий оказывается запрещенным:
Thread1: ref = malloc(A.class); // JVM аллоцировала объект, и держит его адрес где-то у себя в потрохах;
Thread1: VOLATILE STORE a = ref; // Записали адрес объекта в переменную "a";
Thread1: STORE ref.x = 42; // ЗАПРЕЩЕНО! 
Ведь по коду у нас сначала идет запись в "x", а потом запись в "a". А в приведенном примере сначала в "а", а потом в "х". volatile запрещает это делать. 
2) При чтении из volatile переменной срабатывает acquire-семантика, которая означает следующее: "если при чтении из переменной вы увидели некоторое значение, которое было записано с release-семантикой, значит вы гарантированно увидите и все то, что было записано до этого". 

Достигается это путем выставления вокруг volatile-чтений/записей специальных барьеров памяти. Подробнее вот здесь: http://gee.cs.oswego.edu/dl/jmm/cookbook.html (сейчас почему-то не открывается).

В нашем случае мы читаем "a", и видим в ней не-null. Это означает, что к моменту чтения запись в "a" из другого потока уже завершена, а значит завершена и запись в "x", так как по коду запись в "х" предшествует записи в "а".

P.S.: Что значит "инструкции volatile store не существует", я не понял. Мы же говорим про логическое поведение, а не про конкретные инструкции байткода или процессора. На уровне байткода volatile store действительно нет, но такая переменная в байткоде отмечается специальным флагом, которая говорит JVM, что это не простая запись, а волатильная.

Есть такое понятие - program order. Это такой порядок выполнения инструкций, который указан у вас в коде. И действительно, согласно program order инициализация полей объекта происходит до выхода из конструктора. 
А есть настоящий порядок выполнения - тот, который реально происходит на железе. И он там совсем другой из-за:
- out-of-order execution процессора;
- оптимизаций компилятора.
На это переупорядочивание накладываются определенные ограничения: в рамках одного потока инструкции можно переставлять только так, что бы это было неотличимо от program order. Поэтому в однопоточной программе вы никогда не столкнетесь с a.x = 0.
А на многопоточные программы эти гарантии не распространяются. Поэтому вы можете в одном потоке "видеть", что вы вышли из конструктора, и a.x = 42, а в другом потоке "видеть", что a.x = 0. И в этом случае у нас есть только такая гарантия: "при чтении переменной поток гарантированно увидит в ней одно из значений, записанных в нее ранее". То есть, если я записывал в переменную из разных потоков 0, 1, 2, 3, то на очередном ее чтении я не обязательно увижу самое свежее значение 3, но могу увидеть любое предыдущее значение. 


http://gee.cs.oswego.edu/dl/jmm/cookbook.html